package com.springboot.springboot.service.personne;

import com.springboot.springboot.entity.personne.Etudiant;
import com.springboot.springboot.entity.personne.Personne;
import com.springboot.springboot.entity.personne.Indisponibilite;
import com.springboot.springboot.dto.planning.PlanningEtudiantDTO;
import com.springboot.springboot.entity.common.Groupe;
import com.springboot.springboot.entity.planning.SessionFormation;
import com.springboot.springboot.repository.personne.EtudiantRepository;
import com.springboot.springboot.repository.personne.IndisponibiliteRepository;
import com.springboot.springboot.repository.common.GroupeRepository;
import com.springboot.springboot.repository.planning.SessionFormationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service pour gérer les étudiants avec authentification
 */
@Service
@Transactional
public class EtudiantService {

    @Autowired
    private EtudiantRepository repository;

    @Autowired
    private GroupeRepository groupeRepository;
    
    @Autowired
    private IndisponibiliteRepository indisponibiliteRepository;
    
    @Autowired
    private SessionFormationRepository sessionRepository;
    
    private BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    @Transactional(readOnly = true)
    public List<Etudiant> findAll() {
        return repository.findAll();
    }

    @Transactional(readOnly = true)
    public Optional<Etudiant> findById(int id) {
        return repository.findById(id);
    }

    public Etudiant save(Etudiant etudiant) {
        return repository.save(etudiant);
    }

    public void deleteById(int id) {
        repository.deleteById(id);
    }

    /**
     * Méthode pour mettre à jour un étudiant avec gestion des groupes
     */
    public Etudiant updateEtudiant(int id, Etudiant etudiantData) {
        Etudiant existing = repository.findById(id)
                .orElseThrow(() -> new RuntimeException("Étudiant introuvable avec ID: " + id));

        // Mettre à jour les champs simples
        existing.setNom(etudiantData.getNom());
        existing.setPrenom(etudiantData.getPrenom());
        existing.setEmail(etudiantData.getEmail());
        existing.setTelephone(etudiantData.getTelephone());
        existing.setMatricule(etudiantData.getMatricule());
        existing.setNiveau(etudiantData.getNiveau());

        // Mettre à jour le mot de passe seulement s'il est fourni
        if (etudiantData.getPassword() != null && !etudiantData.getPassword().isEmpty()) {
            existing.setPassword(etudiantData.getPassword());
        }

        // Mettre à jour les groupes si présents
        if (etudiantData.getGroupes() != null) {
            // Charger les groupes depuis la base de données
            List<Groupe> groupes = etudiantData.getGroupes().stream()
                    .map(g -> groupeRepository.findById(g.getId())
                            .orElseThrow(() -> new RuntimeException("Groupe introuvable avec ID: " + g.getId())))
                    .collect(Collectors.toList());

            // Remplacer les groupes existants
            existing.getGroupes().clear();
            existing.getGroupes().addAll(groupes);
        }

        return repository.save(existing);
    }
    
    public List<PlanningEtudiantDTO> getPlanningDTOByEtudiantId(int etudiantId) {
        List<SessionFormation> sessions = getSessionsByEtudiantId(etudiantId);

        List<PlanningEtudiantDTO> dtos = sessions.stream()
            .flatMap(session -> session.getCreneaux().stream()
                .map(creneau -> {
                    PlanningEtudiantDTO dto = new PlanningEtudiantDTO();
                    dto.sessionId = session.getId();
                    dto.titre = session.getNomCours();
                    dto.date = creneau.getDate();
                    dto.heureDebut = creneau.getHeureDebut();
                    dto.heureFin = creneau.getHeureFin();
                    dto.jourSemaine = creneau.getJourSemaine();
                    if (session.getFormateur() != null) {
                        dto.nomFormateur = session.getFormateur().getPrenom() + " " + session.getFormateur().getNom();
                    }
                    if (session.getSalle() != null) {
                        dto.nomSalle = session.getSalle().getNom();
                    }
                    if (session.getGroupe() != null) {
                        dto.nomGroupe = session.getGroupe().getNom();
                    }
                    dto.statut = session.getStatut();
                    return dto;
                })
            ).collect(Collectors.toList());

        return dtos;
    }
    
    /**
     * Trouve un étudiant par email (pour login)
     */
    public Optional<Etudiant> findByEmail(String email) {
        return repository.findByEmail(email);
    }
    
    /**
     * Crée un nouveau étudiant avec mot de passe hashé
     */
    public Etudiant createEtudiant(Etudiant etudiant) {
        if (repository.existsByEmail(etudiant.getEmail())) {
            throw new RuntimeException("Email déjà utilisé");
        }
        etudiant.setPassword(passwordEncoder.encode(etudiant.getPassword()));
        etudiant.setRole(Personne.RoleEnum.ETUDIANT);
        etudiant.setActif(true);
        return repository.save(etudiant);
    }
    
    /**
     * Vérifie le mot de passe lors du login
     */
    public boolean verifyPassword(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }
    
    /**
     * Inscription d'un étudiant à un groupe avec vérification de capacité
     */
    public boolean registerToGroupe(int etudiantId, int groupeId) {
        Optional<Etudiant> etudiantOpt = repository.findById(etudiantId);
        Optional<Groupe> groupeOpt = groupeRepository.findById(groupeId);
        
        if (etudiantOpt.isEmpty() || groupeOpt.isEmpty()) {
            return false;
        }
        
        Etudiant etudiant = etudiantOpt.get();
        Groupe groupe = groupeOpt.get();
        
        // Vérifier la capacité du groupe
        if (groupe.getEtudiants().size() >= groupe.getEffectifMax()) {
            throw new RuntimeException("Capacité maximale du groupe atteinte");
        }
        
        // Ajouter l'étudiant au groupe
        etudiant.ajouterAuGroupe(groupe);
        repository.save(etudiant);
        return true;
    }
    
    /**
     * Récupère les sessions d'un étudiant via ses groupes
     */
    public List<SessionFormation> getSessionsByEtudiantId(int etudiantId) {
        Optional<Etudiant> etudiantOpt = repository.findById(etudiantId);
        if (etudiantOpt.isEmpty()) {
            return List.of();
        }
        
        Etudiant etudiant = etudiantOpt.get();
        List<Integer> groupeIds = etudiant.getGroupes().stream()
                .map(Groupe::getId)
                .collect(Collectors.toList());
        
        return sessionRepository.findByGroupeIdIn(groupeIds);
    }
    
    /**
     * Recherche des sessions avec filtres
     */
    public List<SessionFormation> searchSessions(Integer groupeId, LocalDate dateDebut, LocalDate dateFin) {
        if (groupeId != null && dateDebut != null && dateFin != null) {
            return sessionRepository.findByGroupeIdAndDateDebutBetween(groupeId, dateDebut, dateFin);
        } else if (groupeId != null) {
            return sessionRepository.findByGroupeId(groupeId);
        } else if (dateDebut != null && dateFin != null) {
            return sessionRepository.findByDateDebutBetween(dateDebut, dateFin);
        }
        return sessionRepository.findAll();
    }
    
    /**
     * Déclare une indisponibilité urgente pour un étudiant
     */
    public Indisponibilite declareUrgentIndisponibilite(int etudiantId, Indisponibilite indispo) {
        indispo.setTypePersonne("ETUDIANT");
        indispo.setPersonneId(etudiantId);
        indispo.setStatut("EN_ATTENTE");
        return indisponibiliteRepository.save(indispo);
    }
    
    /**
     * Récupère les indisponibilités d'un étudiant
     */
    public List<Indisponibilite> getIndisponibilites(int etudiantId) {
        return indisponibiliteRepository.findByTypePersonneAndPersonneId("ETUDIANT", etudiantId);
    }
    
    /**
     * Calcule les statistiques des sessions d'un étudiant
     */
    public Map<String, Object> getStatistiquesEtudiant(int etudiantId) {
        List<SessionFormation> sessions = getSessionsByEtudiantId(etudiantId);
        LocalDate today = LocalDate.now();
        
        // Compter les sessions terminées, à venir
        long sessionsTerminees = sessions.stream()
                .filter(s -> s.getDateFin() != null && s.getDateFin().isBefore(today))
                .count();
        
        long sessionsAVenir = sessions.stream()
                .filter(s -> s.getDateDebut() != null && s.getDateDebut().isAfter(today))
                .count();
        
        long sessionsEnCours = sessions.stream()
                .filter(s -> s.getDateDebut() != null && s.getDateFin() != null &&
                            !s.getDateDebut().isAfter(today) && !s.getDateFin().isBefore(today))
                .count();
        
        // Calculer le total d'heures en utilisant les créneaux
        double totalHeures = sessions.stream()
                .flatMap(s -> s.getCreneaux() != null ? s.getCreneaux().stream() : java.util.stream.Stream.empty())
                .mapToDouble(c -> {
                    if (c.getHeureDebut() != null && c.getHeureFin() != null) {
                        return java.time.Duration.between(c.getHeureDebut(), c.getHeureFin()).toMinutes() / 60.0;
                    }
                    return 0.0;
                })
                .sum();
        
        // Calculer les heures terminées
        double heuresTerminees = sessions.stream()
                .filter(s -> s.getDateFin() != null && s.getDateFin().isBefore(today))
                .flatMap(s -> s.getCreneaux() != null ? s.getCreneaux().stream() : java.util.stream.Stream.empty())
                .mapToDouble(c -> {
                    if (c.getHeureDebut() != null && c.getHeureFin() != null) {
                        return java.time.Duration.between(c.getHeureDebut(), c.getHeureFin()).toMinutes() / 60.0;
                    }
                    return 0.0;
                })
                .sum();
        
        // Calculer les heures à venir
        double heuresAVenir = sessions.stream()
                .filter(s -> s.getDateDebut() != null && s.getDateDebut().isAfter(today))
                .flatMap(s -> s.getCreneaux() != null ? s.getCreneaux().stream() : java.util.stream.Stream.empty())
                .mapToDouble(c -> {
                    if (c.getHeureDebut() != null && c.getHeureFin() != null) {
                        return java.time.Duration.between(c.getHeureDebut(), c.getHeureFin()).toMinutes() / 60.0;
                    }
                    return 0.0;
                })
                .sum();
        
        return Map.of(
                "totalSessions", sessions.size(),
                "sessionsTerminees", sessionsTerminees,
                "sessionsAVenir", sessionsAVenir,
                "sessionsEnCours", sessionsEnCours,
                "totalHeures", Math.round(totalHeures * 100.0) / 100.0,
                "heuresTerminees", Math.round(heuresTerminees * 100.0) / 100.0,
                "heuresAVenir", Math.round(heuresAVenir * 100.0) / 100.0
        );
    }
}
